/*!
 * el-select-tree v2.1.1-beta.15
 * (c) 2019-2024 yujinpan
 * Released under the MIT License.
 */

'use strict';

var Vue = require('vue');
var getElTreeNodeVirtual = require('./ElTreeNodeVirtual.js');
var utils_js = require('./utils.js');

function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}

/**
 * create when use
 */
function getElTreeVirtual() {
  if (getElTreeVirtual._cache) return getElTreeVirtual._cache;
  var ElTree = Vue.component('ElTree');
  return getElTreeVirtual._cache = {
    extends: ElTree.options,
    components: {
      ElTreeNode: getElTreeNodeVirtual()
    },
    props: {
      dataVirtual: Array
    },
    data: function data() {
      return {
        storeVirtual: null
      };
    },
    watch: {
      dataVirtual: function dataVirtual(newVal) {
        this.storeVirtual.setData(newVal);
      }
    },
    methods: {
      setCheckedNodes: function setCheckedNodes(nodes, leafOnly) {
        if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCheckedNodes');
        this.store.setCheckedNodes(nodes, leafOnly);
        this.storeVirtual.setCheckedNodes(nodes, leafOnly);
      },
      setCheckedKeys: function setCheckedKeys(keys, leafOnly) {
        if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCheckedKeys');
        this.store.setCheckedKeys(keys, leafOnly);
        this.storeVirtual.setCheckedKeys(keys, leafOnly);
      },
      setChecked: function setChecked(data, checked, deep) {
        this.store.setChecked(data, checked, deep);
        this.storeVirtual.setChecked(data, checked, deep);
      },
      getCheckedNodes: function getCheckedNodes(leafOnly, includeHalfChecked) {
        return this.storeVirtual.getCheckedNodes(leafOnly, includeHalfChecked);
      },
      getCheckedKeys: function getCheckedKeys(leafOnly) {
        return this.storeVirtual.getCheckedKeys(leafOnly);
      },
      getHalfCheckedNodes: function getHalfCheckedNodes() {
        return this.storeVirtual.getHalfCheckedNodes();
      },
      getHalfCheckedKeys: function getHalfCheckedKeys() {
        return this.storeVirtual.getHalfCheckedKeys();
      }
    },
    mounted: function mounted() {
      var TreeStore = this.store.constructor;
      this.storeVirtual = utils_js.banReactive(new TreeStore(_objectSpread2(_objectSpread2({}, this.$props), {}, {
        key: this.nodeKey,
        data: this.dataVirtual
      })));
    }
  };
}
getElTreeVirtual._cache = null;

module.exports = getElTreeVirtual;
