/*!
 * el-select-tree v2.1.1-beta.15
 * (c) 2019-2024 yujinpan
 * Released under the MIT License.
 */

import _regeneratorRuntime from '@babel/runtime/helpers/esm/regeneratorRuntime';
import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import _asyncToGenerator from '@babel/runtime/helpers/esm/asyncToGenerator';
import _toConsumableArray from '@babel/runtime/helpers/esm/toConsumableArray';
import 'core-js/modules/es.array.concat.js';
import 'core-js/modules/es.array.filter.js';
import 'core-js/modules/es.array.find.js';
import 'core-js/modules/es.array.from.js';
import 'core-js/modules/es.array.includes.js';
import 'core-js/modules/es.array.push.js';
import 'core-js/modules/es.array.slice.js';
import 'core-js/modules/es.array.splice.js';
import 'core-js/modules/es.number.constructor.js';
import 'core-js/modules/es.object.to-string.js';
import 'core-js/modules/es.regexp.to-string.js';
import 'core-js/modules/es.set.js';
import 'core-js/modules/es.string.includes.js';
import 'core-js/modules/es.string.iterator.js';
import 'core-js/modules/esnext.set.difference.v2.js';
import 'core-js/modules/esnext.set.intersection.v2.js';
import 'core-js/modules/esnext.set.is-disjoint-from.v2.js';
import 'core-js/modules/esnext.set.is-subset-of.v2.js';
import 'core-js/modules/esnext.set.is-superset-of.v2.js';
import 'core-js/modules/esnext.set.symmetric-difference.v2.js';
import 'core-js/modules/esnext.set.union.v2.js';
import 'core-js/modules/web.dom-collections.for-each.js';
import 'core-js/modules/web.dom-collections.iterator.js';
import Vue from 'vue';

var ElSelectMixinOptions = {
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    name: String,
    id: String,
    value: {
      required: true
    },
    autocomplete: String,
    autoComplete: String,
    automaticDropdown: Boolean,
    size: String,
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    allowCreate: Boolean,
    loading: Boolean,
    popperClass: String,
    remote: Boolean,
    loadingText: String,
    noMatchText: String,
    noDataText: String,
    remoteMethod: Function,
    filterMethod: Function,
    multiple: Boolean,
    multipleLimit: Number,
    placeholder: String,
    defaultFirstOption: Boolean,
    reserveKeyword: Boolean,
    valueKey: String,
    collapseTags: Boolean,
    popperAppendToBody: {
      type: Boolean,
      default: true
    }
  }
};
var ElSelectMixin = Vue.extend(ElSelectMixinOptions);
var ElTreeMixinOptions = {
  props: {
    data: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    emptyText: String,
    renderAfterExpand: {
      type: Boolean,
      default: true
    },
    nodeKey: String,
    checkStrictly: Boolean,
    defaultExpandAll: Boolean,
    expandOnClickNode: {
      type: Boolean,
      default: true
    },
    checkOnClickNode: Boolean,
    checkDescendants: Boolean,
    autoExpandParent: {
      type: Boolean,
      default: true
    },
    defaultCheckedKeys: Array,
    defaultExpandedKeys: Array,
    currentNodeKey: [String, Number],
    renderContent: Function,
    showCheckbox: Boolean,
    draggable: Boolean,
    allowDrag: Function,
    allowDrop: Function,
    props: Object,
    lazy: Boolean,
    highlightCurrent: Boolean,
    load: Function,
    filterNodeMethod: Function,
    accordion: Boolean,
    indent: Number,
    iconClass: String
  }
};
var ElTreeMixin = Vue.extend(ElTreeMixinOptions);
function propsPick(props, keys) {
  var result = {};
  keys.forEach(function (key) {
    key in props && (result[key] = props[key]);
  });
  return result;
}
function toArr(val) {
  return Array.isArray(val) ? val : val || val === 0 ? [val] : [];
}
function isValidArr(val) {
  return Array.isArray(val) && !!val.length;
}
function isValidValue(val) {
  return val || val === 0;
}
function getParentKeys(currentKeys, data, getValByProp) {
  var getKeys = function getKeys(tree) {
    var result = [];
    tree.forEach(function (node) {
      var children = getValByProp('children', node);
      if (children && children.length) {
        if (children.find(function (item) {
          return currentKeys.includes(getValByProp('value', item));
        })) {
          result.push(getValByProp('value', node));
        }
        var childrenKeys = getKeys(children);
        if (childrenKeys.length) {
          result.push.apply(result, [getValByProp('value', node)].concat(_toConsumableArray(childrenKeys)));
        }
      }
    });
    return result;
  };
  var result = getKeys(data);
  return Array.from(new Set(result));
}
function cloneValue(val) {
  return Array.isArray(val) ? _toConsumableArray(val) : val;
}
function isEqualsValue(val1, val2) {
  return val1 === val2 || Array.isArray(val1) && Array.isArray(val2) && val1.toString() === val2.toString();
}
function treeFind(treeData, findCallback, getChildren, resultCallback, parent) {
  for (var i = 0; i < treeData.length; i++) {
    var _data = treeData[i];
    if (findCallback(_data, i, treeData, parent)) {
      return resultCallback ? resultCallback(_data, i, treeData, parent) : _data;
    } else {
      var children = getChildren(_data);
      if (isValidArr(children)) {
        var find = treeFind(children, findCallback, getChildren, resultCallback, _data);
        if (find) return find;
      }
    }
  }
}
function treeEach(treeData, callback, getChildren, parent) {
  for (var i = 0; i < treeData.length; i++) {
    var _data2 = treeData[i];
    callback(_data2, i, treeData, parent);
    var children = getChildren(_data2);
    if (isValidArr(children)) {
      treeEach(children, callback, getChildren, _data2);
    }
  }
}
function treeFilter(_x, _x2) {
  return _treeFilter.apply(this, arguments);
}
function _treeFilter() {
  _treeFilter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(data, callback) {
    var propChildren,
      state,
      startTime,
      handleData,
      _args2 = arguments;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          propChildren = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : 'children';
          state = _args2.length > 3 ? _args2[3] : undefined;
          startTime = Date.now();
          handleData = /*#__PURE__*/function () {
            var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(data) {
              var result,
                endTime,
                node,
                hasChildren,
                newItem,
                children,
                newItemChildren,
                _args = arguments;
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    result = _args.length > 1 && _args[1] !== undefined ? _args[1] : [];
                    if (!state.stop) {
                      _context.next = 3;
                      break;
                    }
                    return _context.abrupt("return", Promise.reject());
                  case 3:
                    if (data.length) {
                      _context.next = 5;
                      break;
                    }
                    return _context.abrupt("return", result);
                  case 5:
                    // rest/50ms
                    endTime = Date.now();
                    if (!(endTime - startTime > 50)) {
                      _context.next = 9;
                      break;
                    }
                    _context.next = 9;
                    return new Promise(function (resolve) {
                      startTime = endTime;
                      setTimeout(resolve);
                    });
                  case 9:
                    node = data[0];
                    hasChildren = false;
                    newItem = _objectSpread({}, node);
                    children = node[propChildren];
                    if (!isValidArr(children)) {
                      _context.next = 18;
                      break;
                    }
                    _context.next = 16;
                    return handleData(children);
                  case 16:
                    newItemChildren = _context.sent;
                    if (hasChildren = isValidArr(newItemChildren)) {
                      newItem[propChildren] = newItemChildren;
                    } else {
                      newItem[propChildren] = null;
                    }
                  case 18:
                    if (callback(node) || hasChildren) {
                      result.push(newItem);
                    }
                    return _context.abrupt("return", handleData(data.slice(1), result));
                  case 20:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function handleData(_x3) {
              return _ref.apply(this, arguments);
            };
          }();
          return _context2.abrupt("return", handleData(data));
        case 5:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _treeFilter.apply(this, arguments);
}
function compareArrayChanges(source, target) {
  var add = target.filter(function (item) {
    return !source.includes(item);
  });
  var remove = source.filter(function (item) {
    return !target.includes(item);
  });
  return {
    add: add,
    remove: remove
  };
}
function spliceItem(array, remove) {
  var index = array.indexOf(remove);
  if (index !== -1) {
    for (var _len = arguments.length, add = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      add[_key - 2] = arguments[_key];
    }
    array.splice.apply(array, [index, 1].concat(add));
  }
}
function getCompoundVal(data, prop) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    args[_key2 - 2] = arguments[_key2];
  }
  if (prop instanceof Function) {
    return prop.apply(void 0, [data].concat(args));
  } else {
    return data[prop];
  }
}
var empty = Vue.observable({});
var banReactive = function banReactive(obj) {
  obj.__ob__ = empty['__ob__'];
  return obj;
};

export { ElSelectMixin, ElSelectMixinOptions, ElTreeMixin, ElTreeMixinOptions, banReactive, cloneValue, compareArrayChanges, getCompoundVal, getParentKeys, isEqualsValue, isValidArr, isValidValue, propsPick, spliceItem, toArr, treeEach, treeFilter, treeFind };
